<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">

	<bean id="queryDao" class="com.holler.holler_dao.QueryDao">
		<property name="map">
			<map>

				<entry key="AUTHENTICATE_USER" value="SELECT * FROM user where email = ? and password = ?">
				</entry>
				
				<entry key="AUTHENTICATE_USER_WITH_EMAIL" value="SELECT * FROM user where email = ? AND status= ? ">
				</entry>

				<entry key="GET_USER_JOBS" >
					<value>
						SELECT jobs.* FROM jobs jobs
						JOIN user_job_map map ON  map.jobid = jobs.id
						JOIN USER usr ON (usr.id = map.userid AND usr.id = :requestUserId );
					</value>
				</entry>
				<entry key="GET_JOBS_BY_TAG" >
					<value>
						SELECT j.* FROM
						jobs AS j JOIN job_tag AS jt ON (j.id = jt.job_id AND j.inappropriate_content = :appropriate AND j.status in (:status))
						JOIN tags AS t ON (jt.tag_id = t.id AND t.tag_name LIKE (:searchedTag))
						GROUP BY j.id ORDER BY j.lastModified DESC
					</value>
				</entry>
				<entry key="GET_JOBS_BY_TAG_AND_MEDIUM" >
					<value>
						SELECT j.* FROM
						jobs AS j JOIN job_tag AS jt ON (j.id = jt.job_id AND j.inappropriate_content = :appropriate AND j.status in (:status) AND j.job_medium = :medium)
						JOIN tags AS t ON (jt.tag_id = t.id AND t.tag_name LIKE (:searchedTag))
						GROUP BY j.id ORDER BY j.lastModified DESC
					</value>
				</entry>
				<entry key="GET_JOBS_FOR_USER" >
					<value>
						SELECT j.* FROM
						jobs AS j WHERE j.userId NOT IN (:userId) AND j.inappropriate_content = :appropriate AND j.status in (:status)
						ORDER BY j.lastModified DESC
					</value>
				</entry>
				<entry key="GET_ACCEPTED_USERS_BY_JOB_ID" >
					<value>
						select usr.id, usr.name, usr.pic, uj.status,usr.avg_rating , usr.is_user_verified
						from user usr
						join user_job uj on usr.id = uj.userId
						And uj.jobId=:jobId and uj.status IN (:userJobStatus);
					</value>
				</entry>
				<entry key="GET_JOBS_BY_TAG_IDS_OLD" >
					<value>
						SELECT *,
							CASE WHEN X.tagIds = :tagIdsString THEN 0 ELSE 1 END AS jobOrder
						FROM (
							SELECT
								j.*,
								GROUP_CONCAT(t.id) AS tagIds
							FROM
								jobs AS j JOIN job_tag AS jt ON (j.id = jt.job_id AND j.inappropriate_content = :appropriate AND j.status in (:status))
								JOIN tags AS t ON (jt.tag_id = t.id AND t.id IN (:tagIds))
								GROUP BY j.id
						) AS X
						ORDER BY jobOrder ASC
					</value>
				</entry>
				<entry key="GET_JOBS_BY_TAG_IDS" >
					<value>
						SELECT
							j.*
						FROM
							jobs AS j JOIN job_tag AS jt ON (j.id = jt.job_id AND j.inappropriate_content = :appropriate AND j.status in (:status) AND j.userId NOT IN (:userId))
							JOIN tags AS t ON (jt.tag_id = t.id AND t.id IN (:tagIds))
							GROUP BY j.id ORDER BY j.lastModified DESC
					</value>
				</entry>
				<entry key="ACCEPT_JOB" >
					<value>
						INSERT INTO user_job(userId, jobId, status, job_accepted_date ) VALUES(:userId, :jobId, :status, :acceptedDate)
					</value>
				</entry>
				<entry key="UNACCEPT_JOB" >
					<value>
						DELETE FROM user_job WHERE userId = :userId AND jobId = :jobId
					</value>
				</entry>
				<entry key="UPDATE_USER_JOB" >
					<value>
						UPDATE user_job SET status = :status WHERE userId = :userId AND jobId = :jobId
					</value>
				</entry>
				<entry key="UPDATE_JOB_PROVIDER_RATING_FLAG" >
					<value>
						UPDATE user_job SET provider_rating_flag = :flag WHERE userId = :userId AND jobId = :jobId
					</value>
				</entry>

				<entry key="UPDATE_JOB_ACCEPTER_RATING_FLAG" >
					<value>
						UPDATE user_job SET accepter_rating_flag = :flag WHERE userId = :userId AND jobId = :jobId
					</value>
				</entry>

				<entry key="GET_TAGS_FOR_USER_HOME_PAGE" >
					<value>
						SELECT X.* FROM
						(
							SELECT
								t.*,
								CASE WHEN ut.user_id > 0 THEN 0 ELSE 1 END AS tagOrder
							FROM
								job_tag jt
								JOIN tags t ON jt.tag_id = t.id
								LEFT JOIN (SELECT * FROM user_tag WHERE user_id = :userId) ut ON jt.tag_id = ut.tag_id
								GROUP BY jt.tag_id
						) AS X ORDER BY X.tagOrder ASC
					</value>
				</entry>
				<entry key="GET_MY_PINGED_JOBS" >
					<value>
						SELECT j.id, j.job_title,j.job_description, j.compensation, uj.job_accepted_date, uj.status FROM jobs j JOIN user_job uj ON
							j.id = uj.jobId AND uj.userId = :userId
							order by uj.job_accepted_date desc
					</value>
				</entry>
				<entry key="GET_USERS_IDS_BY_TAG_IDS" >
					<value>
						SELECT DISTINCT(user_id) FROM user_tag WHERE tag_id IN (:tagIds)
					</value>
				</entry>
				<entry key="GET_ACCEPTED_USERS_IDS_BY_JOB_ID" >
					<value>
						SELECT DISTINCT(userId) FROM user_job WHERE jobId = :jobId ;
					</value>
				</entry>
				<entry key="GET_USERS_UNREAD_NOTIFICATION_COUNT" >
					<value>
						SELECT count(*) from notification where to_user = :userId and is_seen  = 0;
					</value>
				</entry>
				<entry key="GET_USERS_UNSEEN_NOTIFICATION_AND_MESSAGES_COUNT" >
					<value>
						SELECT
						(SELECT COUNT(*) FROM notification where to_user = :userId AND is_seen = false ) as notificationCount ,
						(SELECT COUNT(*) FROM
							(SELECT * FROM user_msg where to_user_id = :userId AND is_seen = false group by from_user_id) as messageCountTemp
						) as messageCount
					</value>
				</entry>
				<entry key="GET_NOTIFICATION_TEMPLATE">
					<value>
						SELECT nt.id, nt.from_user, usr.name, usr.pic, nt.to_user, ntt.type, nt.object_id, usr.name, jb.job_title, temp.note, nt.is_read, nt.created
						FROM notification nt
						LEFT JOIN notification_type ntt on (nt.notification_type = ntt.type)
						LEFT JOIN template_notification_type_map tnm ON (ntt.id = tnm.notification_type_id)
						LEFT JOIN template temp ON (tnm.temp_id = temp.id)
						LEFT JOIN jobs jb ON (nt.object_id = jb.id)
						LEFT JOIN user usr ON (nt.from_user  = usr.id)
						where nt.to_user = :userId order by nt.created desc;
					</value>
				</entry>
				
				<entry key="GET_PARTICULAR_NOTIFICATIONS_FOR_USER">
					<value>
						SELECT nt.id, nt.from_user, usr.name, usr.pic, nt.to_user, ntt.type, nt.object_id, usr.name, jb.job_title, temp.note, nt.is_read, nt.created
						FROM 
						(SELECT * FROM notification WHERE id = :notificationId) nt
						LEFT JOIN notification_type ntt on (nt.notification_type = ntt.type)
						LEFT JOIN template_notification_type_map tnm ON (ntt.id = tnm.notification_type_id)
						LEFT JOIN template temp ON (tnm.temp_id = temp.id)
						LEFT JOIN jobs jb ON (nt.object_id = jb.id)
						LEFT JOIN user usr ON (nt.from_user  = usr.id)
						where nt.to_user = :userId order by nt.created desc;
					</value>
				</entry>
				<entry key="MARK_ALL_NOTIFICATION_AS_SEEN" >
					<value>
						UPDATE notification SET is_seen = 1 WHERE to_user = :userId
					</value>
				</entry>
				<entry key="GET_USER_JOB_STATUS" >
					<value>
						SELECT uj.jobid, uj.userid, uj.status, usr.name, usr.pic, avg_rating ,usr.is_user_verified from
						user_job uj
						JOIN user usr ON (uj.userid = usr.id )
						where jobid = :jobId
					</value>
				</entry>
				<entry key="GET_MY_POSTED_AND_PINGED_JOB_IDS" >
					<value>
						SELECT id FROM jobs where userId = :userId
						UNION
						SELECT jobId FROM user_job where userid = :userId
					</value>
				</entry>
				<entry key="GET_USER_FOR_RATING_SCREEN">
					<value>
						SELECT result.id userId, result.name, result.pic, result.jobId, result.jobTitle, jobDesignation
						FROM
						(
							SELECT usr.*, j.id as jobId, j.job_title as jobTitle, "PROVIDER" as jobDesignation from
							jobs j
							JOIN user_job uj ON (j.id = uj.jobid AND uj.status=:userJobStatus)
							JOIN user usr ON (uj.userid = usr.id)
							WHERE j.userId = :userId
							AND uj.provider_rating_flag=:ratingFlag

						UNION

							SELECT usr.*, j.id as jobId, j.job_title as jobTitle, "ACCEPTER" as jobDesignation from
							user_job uj
							JOIN jobs j ON (uj.jobid = j.id AND uj.accepter_rating_flag= :ratingFlag AND uj.status=:userJobStatus)
							JOIN user usr ON (j.userId = usr.id)
							WHERE uj.userid = :userId
						) result;
					</value>
				</entry>
				<entry key="GET_USER_RATING_DATA">
					<value>
						SELECT usr.id, usr.name, usr.pic, ur.rating, ur.feedback, ur.created, j.job_title as title, j.compensation from user_ratings ur
						JOIN user usr ON (ur.from_user = usr.id)
						JOIN jobs j ON (ur.object_id = j.id)
						WHERE ur.to_user= :userId order by ur.created desc ;
					</value>
				</entry>
				<entry key="DOES_USER_HAS_INCOMPLETE_JOB">
					<value>
						SELECT * FROM user_job WHERE userid = :userId AND status IN (:userJobStatus) ;
					</value>
				</entry>
				<entry key="UPDATE_JOB_STATUS" >
					<value>
						UPDATE jobs SET status = :status WHERE id = :jobId
					</value>
				</entry>
				<entry key="GET_USER_JOBS_FROM_JOB_ID" >
					<value>
						SELECT * FROM user_job where jobid = :jobId 
					</value>
				</entry>
				<entry key="SET_PARENT_TAG_IMAGE_URL" >
					<value>
						UPDATE parent_tags SET tag_image_url = :tagUrl WHERE id = :tagId
					</value>
				</entry>
				<entry key="SET_CHILD_TAG_IMAGE_URL" >
					<value>
						UPDATE tags SET tag_image_url = :tagUrl WHERE id = :tagId
					</value>
				</entry>
				<entry key="GET_ALL_CONVERSATION_FOR_USER">
					<value>
						SELECT * FROM (
						SELECT temp.*, usr.id as userId, usr.name, usr.pic FROM
						(select * from user_msg where from_user_id = :userId or to_user_id = :userId order by created desc) temp
						JOIN user usr ON ((usr.id = temp.to_user_id OR usr.id = temp.from_user_id) AND usr.id &lt;&gt; :userId ) group by userId
						)result order by created desc;
					</value>
				</entry>
				<entry key="GET_CONVERSATION_FOR_USER">
					<value>
						SELECT * FROM user_msg WHERE from_user_id = :fromUserId AND to_user_id = :toUserId
							UNION
						SELECT * FROM user_msg WHERE from_user_id = :toUserId AND to_user_id = :fromUserId
						order by created;
					</value>
				</entry>
				<entry key="MARK_ALL_MESSAGES_AS_SEEN" >
					<value>
						UPDATE user_msg SET is_seen = 1 WHERE to_user_id = :userId
					</value>
				</entry>
				<entry key="MARK_ALL_MESSAGES_AS_READ">
					<value>
						UPDATE user_msg SET is_read = 1 WHERE from_user_id = :toUserId AND to_user_id = :userId
					</value>
				</entry>
				<entry key="MARK_NOTIFICATION_AS_READ">
					<value>
						UPDATE notification SET is_read = 1 WHERE id = :notificationId
					</value>
				</entry>
			</map>
		</property>
	</bean>

</beans>